# NUT-AC-00: Introduction & General Scheme Overview

`mandatory`

---

This document details the notation and models used throughout the specification and lays the groundwork for understanding the basic cryptography used in the Cashu AC (Anonymous Credentials) protocol extension.

- Sending user: `Alice`
- Receiving user: `Carol`
- Mint: `Bob`

# Keyed-Verification Anonymous Credentials (KVAC)

## `hash_to_curve(x: bytes) -> curve point Y`

Deterministically maps a message to a public key point on the secp256k1 curve, utilizing a domain separator to ensure uniqueness.

`Y = PublicKey('02' || SHA256(msg_hash || counter))` where `msg_hash` is `SHA256(DOMAIN_SEPARATOR || x)`

- `Y` derived public key
- `DOMAIN_SEPARATOR` constant byte string `b"Secp256k1_HashToCurve_Cashu_"`
- `x` message to hash
- `counter` uint32 counter(byte order little endian) incremented from 0 until a point is found that lies on the curve

## Generators

Generators are points on the `secp256k1` curve can be used as a basis from which it's possible to compute any other point on the curve through repetitive adding.

Each generator is derived using NUMS (Nothing Up My Sleeve) as `hash_to_curve(<generator_name_or_subscript>)`.

For example, $G_w$ is obtained by inputting the subscript `w` into `hash_to_curve`:

```
G_w = hash_to_curve("w")
```

This ensures that the discrete logarithm relation between any pair of them remains unknown.

The term "generator" here is used loosely. While NUMS points might not necessarily generate the entire group of points on the curve, they can still be considered generators in the sense that they can be used to derive a large number of other points through repeated point addition:

- $G_w, G_{w'}, G_{x_0}, G_{x_1}$: Used for computation of the algebraic MAC (on the Mint's side) and later in credential presentation.
- $G_\text{zmac}, G_\text{zamount}, G_\text{zscript}$: Used in credential presentation.
- $G_\text{amount}, G_\text{script}$: Used for encoding amounts and scripts (spending conditions).
- $G_\text{blind}$: Used for the blinding terms.

## Mint Keys

`MintPrivateKey` is a single tuple of six secret values (for all amounts):

```math
sk = (w, w', x_0, x_1, y_a, y_s)
```

- $y_a$: key for signing amount commitments.
- $y_s$: key for signing script commitments.
- $w, w', x_0, x_1$: additional secret values needed for the algebraic MAC as presented in [[1]].

`MintPublicKey` is a tuple $(I, C_w)$, calculated as:

```math
\displaylines{
\begin{align}
I &= G_\text{zmac} - (x_0\cdot G_{x_0} + x_1\cdot G_{x_1} + y_a\cdot G_\text{zamount} + y_s\cdot G_\text{zscript})\\
C_w &= w\cdot G_w + w'\cdot G_{w'}
\end{align}
}
```

## Pedersen Commitments

A Pedersen Commitment is a cryptographic primitive used to commit to a chosen value while keeping it hidden.

Given two generators $G$ and $H$ such that the discrete logarithm relation between them is unknown, a Pedersen Commitment that hides a secret value $a$ with blinding factor $r$ is computed as:

```math
    M = a\cdot G + r\cdot H
```

This commitment has certain properties that make it particularly useful:

- **Hiding**: The commitment doesn't reveal the value. This means that given the commitment, one cannot infer the original value $a$.

- **Binding**: Once committed to a value, one cannot change it. This ensures that one can't claim the commitment represents some other value.

- **Homomorphism**: Pedersen Commitments have a mathematical property where commitments can be combined.

## Attributes

A `AmountAttribute` is tuple $(a, r)$ where $a$ is a scalar value encoding an amount in Big-Endian format and $r_a$ is a scalar chosen uniformly at random.

If you know `AmountAttribute` you can derive its commitment value:

```math
M_a = a \cdot G_\text{amount} + r_a \cdot G_\text{blind}
```

A `ScriptAttribute` is a tuple $(s, r)$ where $s$ is a scalar value encoding the SHA-256 hash of a particular script or spending condition, and $r_s$ is a scalar chosen uniformly at random.

Likewise, if you know `ScriptAttribute` you can derive its commitment value:

```math
M_s = s \cdot G_\text{script} + r_s \cdot G_\text{blind}
```

## MAC (Message Authentication Code)

A `MAC` is a pair $(t, V)$ of a scalar $t$ and a curve point $V$ issued by `Bob` on a pair of attribute commitments $(M_a, M_s)$ and represents the "approval stamp" or "signature" that `Bob` is willing to attribute to said commitments.

$t$ -also referred to as "tag"- is chosen uniformly at random by `Alice`, while $V$ is computed by `Bob` as follows:

```math
\displaylines{
U = \text{hashToCurve}(t)\\
V = w\cdot G_w + x_0 \cdot U + x_1 \cdot t \cdot U + y_a\cdot M_a + y_s\cdot M_s
}
```

## Coin

A `Coin` is a collection of the following:

- `MAC`
- `AmountAttribute`
- `ScriptAttribute`.

`Alice` can put together a `Coin` after receiving the `MAC` from `Bob`.

## Protocol

This section describes the protocol, which is composed by 3 phases:

1. **Bootstrap**: Una-tantum phase in which `Alice` asks `Bob` for a `MAC` on commitments encoding $0$. Since every request in the protocol expects inputs and outputs, this step is crucial for getting initial inputs.

2. **Issuance**: `Alice` pays `Bob` and asks to issue a `MAC` on commitments that encode value

3. **Redemption**: `Alice` presents `Bob` with valid coins and requests a payout.

> [!NOTE]
> Phases 2 and 3 always happen simultaneously: `Alice` presents valid credentials and asks for new ones in **EVERY** request.

We use $\pi_\text{<subscript>}$ to refer to Zero-Knowledge proofs. For the time being it's useful to just imagine them as an "evidence" black box. They are thoroughly described in a later section.

### Bootstrap

0. `Bob` publicly announces `MintPublicKey`
1. `Alice` produces an `AmountAttribute` commitment $M_a$ that encodes $0$ and a `ScriptAttribute` commitment $M_s$ that encodes $s = H("")$.
2. `Alice` generates $\pi_\text{bootstrap}$, to show that $M_a$ encodes $0$ without revealing the blinding factor $r_a$.
3. `Alice` sends $(t, M_a, M_s, \pi_\text{bootstrap})$ to `Bob`, where $t$ is a scalar chosen uniformly at random.
4. `Bob` verifies $\pi_\text{bootstrap}$ and issues a `MAC` on $(M_a, M_s)$.
5. `Bob` generates $\pi_\text{issuance}$, to prove that `MAC` was issued with `MintPrivateKey`.
6. `Alice` receives $(t, V, \pi_\text{issuance})$ and verifies $\pi_\text{issuance}$.
7. `Alice` saves `Coin(AmountAttribute, ScriptAttribute, MAC)`

### Issuance & Redemption

0. `Bob` publicly announces `MintPublicKey`

1. `Alice` creates request <u>outputs</u>: **new** `AmountAttribute` and `ScriptAttribute` pairs that encode respectively the final wallet balance (minus any fees) and, optionally, the hash of the script describing the spending conditions.

2. `Alice` creates request <u>inputs</u> by taking a previously received `Coin` that encodes the current balance and randomizing it into a `RandomizedCoin`. "Randomizing" is what breaks the link to the issuance. The process works as follows:
    `(AmountAttribute, ScriptAttribute, MAC) = Coin`
   - $U = \text{HashToCurve}(t)$, where $t$ is the `MAC` scalar value
   - $C_a = r_a\cdot G_\text{zamount} + M_a$, where $r_a$ is the blinding value for `AmountAttribute`.
   - $C_s = r_a\cdot G_\text{zscript} + M_s$
   - $C_{x_0} = r_a\cdot G_{x_0} + U$
   - $C_{x_1} = r_a\cdot G_{x_1} + t\cdot U$
   - $C_v = r_a\cdot G_\text{zmac} + V$, where $V$ is the `MAC` public point value
   - `RandomizedCoin`: $(C_a, C_s, C_{x_0}, C_{x_1}, C_v)$

> [!NOTE]
> Slight deviation from the original KVAC scheme, where the value is picked as a random $z$.
> We choose to use $r_a$ because it makes $\pi_\text{MAC}$ slightly less bulky and simplies things.

3. `Alice` generates the following Zero-Knowledge Proofs:

   - $\pi_\text{balance}$: Proves that the balance difference $\Delta_a$ between inputs and outputs is consistent with the request's claim.
   - $\pi_\text{range}$: For each new `AmountAttribute` in the outputs, proves the committed value is within the range $[0, L-1]$, where $L$ is some agreed upon bound.
   - $\pi_\text{MAC}$: For each `RandomizedCoin` shows that it indeed is the valid randomized version of <u>some</u> existing `Coin`.

4. `Alice` sends $((C_a, C_s, C_{x_0}, C_{x_1}, C_v), (t, M_a, M_s), \pi_\text{balance}, \pi_\text{range}, \pi_\text{MAC})$, where $t$ is a scalar chosen uniformly at random. 
5. `Bob` verifies $\pi_\text{balance}, \pi_\text{range}, \pi_\text{MAC}$, and that the same $C_a$ value wasn't presented in a previous request. This prevents any double-spends of the same coin.
6. `Bob` issues a `MAC` on $(t, M_a, M_s)$.
7. `Bob` generates $\pi_\text{issuance}$, to prove that `MAC` was issued with `MintPrivateKey`.
8. `Alice` receives $(t, V, \pi_\text{issuance})$ and verifies $\pi_\text{issuance}$.
9. `Alice` saves `Coin(AmountAttribute, ScriptAttribute, MAC)`.

---

## Sigma-Protocol Zero-Knowledge Proofs
In the simplest case of a Sigma-protocol zero-knowledge proof, a prover demonstrates knowledge of a the same secret value used to compute 2 public inputs without revealing it. Consider a specific example where the prover knows a secret value $x$ and has computed two public points:
- $X = x·G$ (where $G$ is a standard generator point)
- $X_A = x·A$ (where $A = a·G$ for some unknown value $a$)

The protocol proceeds as follows:

### Step 1: Commitment
The prover creates a random value $k$ (a "nonce") and computes:
- $R1 = k\cdot G$
- $R2 = k\cdot A$

These values are called public nonce-commitments, representing a temporary "hiding" of information.

### Step 2: Challenge
The verifier (or a hash function in non-interactive mode) creates a random challenge $c$.

### Step 3: Response
The prover computes a response: $z = k + c\cdot x$

### Step 4: Verification
The verifier checks two equations:
1. Does $R1 \stackrel{?}= z\cdot G - c\cdot X$?
2. Does $R2 \stackrel{?}= z\cdot A - c\cdot X_A$?

The verification works mathematically because:

For the first equation:
- $k\cdot G = z\cdot G - c\cdot X = (k + c\cdot x)\cdot G - c\cdot X = k\cdot G + c\cdot x\cdot G - c\cdot X = R1 $

For the second equation:
- $k\cdot G = z \cdot A - c \cdot X_A = (k + c\cdot x) \cdot A - c\cdot X_A = k\cdot A + c\cdot x\cdot A - c \cdot X_A = R2$

If both equations check out, the verifier is convinced of the prover's knowledge of $x$ without learning its value.

### Zero-Knowledge Properties
- The random $k$ hides any information about $x$
- The challenge $c$ ensures the prover cannot cheat
- The response $z$ combines randomness with the secret in a way that reveals nothing about the secret itself

### Knowledge Soundness
If the prover can provide the correct response z for any random challenge c, it strongly suggests knowledge of the secret x, because the mathematical relationship between z, the commitments, and the public values only works if the correct x is known.

---

## Extending Sigma-Protocols to Multi-Commitment Linear Proofs

Sigma-protocols can be extended to prove multiple linear relations simultaneously, creating more efficient proofs for complex statements. This extension allows a prover to demonstrate knowledge of multiple secret values that satisfy various linear relations.

### Multi-Commitment Linear Proofs

Consider a scenario where a prover needs to demonstrate knowledge of multiple secret values $x_1, x_2, ..., x_n$ that satisfy several linear relations. Instead of creating separate proofs for each relation, a single proof can be constructed.

### Setup
The prover has computed several public commitments from secret values:
- $X_1 = x_1 \cdot G$
- $X_2 = x_2 \cdot G$
- $...$
- $X_n = x_n \cdot G$

And potentially additional public commitments representing linear combinations:
- $Y_1 = a_{11}x_1 + a_{12}x_2 + ... + a_{1n}x_n$ (commitment to first linear relation)
- $Y_2 = a_{21}x_1 + a_{22}x_2 + ... + a_{2n}x_n$ (commitment to second linear relation)
- $...$
- $Y_m = a_{m1}x_1 + a_{m2}x_2 + ... + a_{mn}x_n$ (commitment to mth linear relation)

### Protocol Structure

The protocol can be organized in a tabular form:

| Step | Commitments (Rows) | Witnesses/Responses (Columns) |
|------|--------------------|-----------------------------|
| 1. Commitment | Generate random values $k_1, k_2, ..., k_n$<br>Compute commitments $R_i = k_i \cdot G$ for each secret<br>Compute additional commitments for each linear relation | The commitment matrix contains all $R_i$ values and additional commitments for linear relations |
| 2. Challenge | Receive a single challenge value $c$ | Challenge $c$ applies across all relations |
| 3. Response | Compute $z_i = k_i + c \cdot x_i$ for each secret | The response vector contains all $z_i$ values |
| 4. Verification | For each base commitment: $z_i \cdot G \stackrel{?}{=} R_i + c \cdot X_i$<br>For each linear relation: verify the corresponding equation using the responses | Verifier checks all equations in parallel |

### Example with Two Secrets and One Linear Relation

Consider proving knowledge of secrets $x_1$ and $x_2$ where they also satisfy $x_1 + 2x_2 = m$ for some public value $m$.

| Commitments | Secret $x_1$ | Secret $x_2$ | Linear Relation $x_1 + 2x_2 = m$ |
|-------------|----------------|----------------|-------------------------------------|
| Public Values | $X_1 = x_1 \cdot G$ | $X_2 = x_2 \cdot G$ | $Y = m \cdot G$ |
| Commitment Step | $R_1 = k_1 \cdot G$ | $R_2 = k_2 \cdot G$ | $R_3 = (k_1 + 2k_2) \cdot G$ |
| Response (for challenge $c$) | $z_1 = k_1 + c \cdot x_1$ | $z_2 = k_2 + c \cdot x_2$ | (uses $z_1$ and $z_2$) |

### Verification
The verifier checks:
1. $z_1 \cdot G \stackrel{?}{=} R_1 + c \cdot X_1$
2. $z_2 \cdot G \stackrel{?}{=} R_2 + c \cdot X_2$
3. $(z_1 + 2z_2) \cdot G \stackrel{?}{=} R_3 + c \cdot Y$

### Advantages
- Single challenge for multiple relations
- Reduced communication complexity
- Compact proof size
- Can be made non-interactive using Fiat-Shamir heuristic

This approach scales efficiently to proving arbitrary systems of linear relations among secret values, making it powerful for applications like confidential transactions, polynomial commitments, and range proofs.

[1]: https://signal.org/blog/pdfs/signal_private_group_system.pdf
